#!/usr/bin/perl

# this script takes the coverage bedgraph file generated by StringTie and the junction file (for now needs to be processed with process_junctions_perc.pl) and produces bundles and anchor points for the USG
# e.g. ./process_tiebrush.pl /ccb/salz4-2/mpertea/GTEX_stringtie/chess3/tiebrush_results/Brain/Brain.def.coverage.bedgraph /ccb/salz4-2/mpertea/GTEX_stringtie/chess3/tiebrush/Brain.processed.junctions.bed > Brain.bundles

#### TO DO:
#### - it would be good to have a way of cleaning up ends from detected tstarts/tends that are under lowcov
#### - the lowcov threshold for bundles might eliminate real expressed regions if the bundles extend far away and lower coverage overall
#### - eliminate higher count junctions that connect maximally connected junctions if they look suspicious -> this will avoid increasing lowcov and will clean up the bundles more

use strict;

# global parameters:
my $lowcov=10; # just trying to see if it breaks more bundles I tried 50, and it did! -> should be adjusted on sample size
my $splicenoise=0.01; # reject if splice count is less than that and not a trusted splice
my $percnoise=0.2; # observed drop for tstart and tend to happen
my $highnoise=0.005;
my $smallcov=50; # accept if it passes above, but doesn't pass percsame/percdifferent
my $highcov=100; # this are junctions under splicenoise that are still trustable (maybe?)
my $delta=5; # distance to evaluate the junction drop (strength)
my $win=150; # window to assess coverage drops? and distances from start/stops
my $smallwin=25; # minimum allowed window size for detecting tstart/tend
  
my ($covfile,$juncfile)=@ARGV; # juncfile is the processed one (the one obtained with process_junctions_perc.pl) 

my $fJ; # file junction handler

open(C,$covfile); <C>; # coverage bedgraph file: first line is track
open($fJ,$juncfile); <$fJ>; # junction file: first is track

my $bundleno=0; # bundle number detected so far
my $chr=""; # last read chromosome in file

my $bundleend=0; # current bundle end

my @covg=(); # coverages in bundle from bedgraph file: 0:start, 1:end, 2:coverage
my @junc=(); # this are junctions that were already added to the bundle: 0:chrname 1:start 2:end 3:cov 4:strand 5:percentage from maximal overlapping junction
my @unprocjunc=(); # this are junctions that were read but are not in the bundle yet; same as @junc


while(<C>) { # read coverage file, one line at a time
  chomp;
  my ($chrname,$start,$end,$cov)=split(/\t/); # these are the info in the line
  $start++; # adjust start to get 1-based coordinates
  
  if($start>$bundleend+1 || ($chrname ne $chr)) { # new bundle if there is a change in chromosome or start is after bundleend and at a distance (there is at least a 1bp between them)

    $bundleno=process_bundle(\@covg,\@junc,$chr,$bundleno); # process previous bundle first
    if($chr ne $chrname) { $chr=$chrname; }  # update chromosome name
    $bundleend=0; # set current bundleend
  }
  
  if($end>$bundleend) { $bundleend=$end;} # update bundleend
  push(@covg,[($start,$end,$cov)]); # push 
  
  my $toadd=add_procjunc_to_bundle(\@junc,\@unprocjunc,\$bundleend,$chr); # add all previously read junctions to the junc array if they start before bundleend
  
  #print STDERR "toadd=$toadd\n";
  
  if($toadd) { # I need to read more junctions from the file
    $bundleend=add_junc_to_bundle(\@junc,\@unprocjunc,$chr,$bundleend,$fJ);
  }

  
}
close(C);
close($fJ);

# process last remaining bundle
$bundleno=process_bundle(\@covg,\@junc,$chr,$bundleno); 

## this function takes a bundle as determined so far and tries to see if it can filter the data more and split it into smaller bundles
sub process_bundle { 
  my ($covg,$junc,$chr,$bundleno)=@_;
  
  my $nb=scalar(@{$covg}); # number of regions with different coverages in the bundle
  if($nb) {
    
    my $avg=0; # average coverage of entire bundle
    my $len=0; # length of transcribed regions in bundle
    
    my @s; # contiguous regions as array of ([(covg_index_start,covg_index_end)],...,) 0:start 1:end
    my $preve=-1; # previous covg end

    my $seengoodavg=0; # indicates if I saw a contiguous region over lowcov (def.10)
    my $runavg=0; # coverage of current contiguously covereg region
    
    for(my $i=0;$i<$nb;$i++) { # determines the contiguous regions
      
      if($$covg[$i][0]-1>$preve) { # not contiguous -> there is a gap in coverage
	if(!$seengoodavg && $runavg && $runavg/($$covg[$s[-1][1]][1]-$$covg[$s[-1][0]][0]+1)>$lowcov) { $seengoodavg=1;}
	$runavg=0;
	push(@s,[($i,$i)]); # remembers a starting covg
      }
      
      $s[$#s][1]=$i; # update ending
      $preve=$$covg[$i][1];      
      my $clen=$$covg[$i][1]-$$covg[$i][0]+1;
      $avg+=$$covg[$i][2]*$clen;
      if(!$seengoodavg) { $runavg+=$$covg[$i][2]*$clen;}
      $len+=$clen;
      
    }
    $avg/=$len;
    if($runavg && $runavg/($$covg[$s[-1][1]][1]-$$covg[$s[-1][0]][0]+1)>$lowcov) { $seengoodavg=1;}

    if($len>$win && $seengoodavg) { # only consider bundles that are big enough and had a contiguous region above lowcov; default lowcov=5; and win=150

      # DEBUG only
      print STDERR "bundle\t$chr\t$bundleno\t",$$covg[0][0],"\t",$$covg[$nb-1][1]," avg=",$avg," len=$len\n";
      print STDERR "There are ",scalar(@s)," contiguous regions\n";
      
      my $nj=scalar(@{$junc});      
      my @jend=sort { $$junc[$a][2] <=> $$junc[$b][2]} 0..($nj-1); # sort junctions based on their ends; only junction starts are sorted; jend stores junc indices in an order where ends are from smalles to biggest

      # procedure to filter junction more; if junction j is eliminated its coverage is set to 0: junc[j][3]=0
      process_junctions(\@{$junc},\@jend,$nj); 

      # find drops in coverage (predicted tstarts and tends 
      my @drop=(); # 0: position; 1: drop percentage; 2: coverage difference across window size

      my $js=0; # current index in junc
      my $je=0; # current index in jend
      for(my $i=0;$i<scalar(@s);$i++) { # for all contiguous regions find drops in coverage
	($js,$je)=get_drop($covg,$s[$i][0],$s[$i][1],\@drop,$nb,$junc,\@jend,$js,$je,$nj);
      }

      my $nd=scalar(@drop)-1; # last point to process is an end and I don't want to process it in the while loop below


      # DEBUG only
      #print STDERR "Start junctions:";for(my $i=0;$i<scalar(@{$junc});$i++) { print STDERR " ",$$junc[$i][1];} print STDERR "\n";
      #print STDERR "End junctions:";for(my $i=0;$i<scalar(@jend);$i++) { print STDERR " ",$jend[$i],":",$$junc[$jend[$i]][2];} print STDERR "\n";
      


      ## Compute records: groups junctions by their start/end; process computed tstart/tends so they do not overlap junction start/ends; computes average coverage to next record
      # record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point_in between points (0 if adjacent)
      my @record;
      
      my $ib=0; # current covg to process
      my $id=0; # curent drop to process; drops include start/end of bundles 
      $js=0; # curent junction start to process
      $je=0; # current junction end to process

      # first record is the start of the bundle (first coverage start
      push(@record,[("tstart",$$covg[0][0],[(0)],0,$$covg[0][2],0)]);
      $id++; # first drop is always the first covg's start

      my $prevpos=$$covg[0][0]; # previous position added to record
      
      while($id<$nd || $js<$nj || $je<$nj) {
	($ib,$id,$js,$je,$prevpos)=get_record($covg,\@drop,$junc,\@jend,$prevpos,$ib,$id,$js,$je,$nb,$nd,$nj,\@record,$chr);
      }

      # DEBUG only:
      # print last record which is the end of last coverage
      # print STDERR "nb=$nb end of record is ", $$covg[$nb-1][1]," at position ",scalar(@record),"\n";
      
      if($$covg[$nb-1][1]>$prevpos+1) { # do not include end points to avoid confusion
	my $avgcov=0;
	($avgcov,$ib)=get_cov($prevpos+1,$$covg[$nb-1][1]-1,$covg,$ib,$nb); # do not include end points
	$record[-1][-1]+=$avgcov;
      }
      
      push(@record,[("tend",$$covg[$nb-1][1],[($nd)],0,$$covg[$nb-1][2],0)]);      
      
      $bundleno=process_records(\@record,$chr,$bundleno,\@drop,$junc); # process records in bundle to prepare them for printing

    }

  }

  # clean-up memory
  @{$covg}=();
  @{$junc}=();

  return($bundleno);
  
}

## this function prepares for printing by rebundling records (due to junction filtering some bundles might split into smaller ones)
sub process_records { 
  my ($record,$chr,$bundleno,$drop,$junc)=@_;

  my $n=scalar(@{$record}); # number of records

  # sanity check: make sure that last record is a tend
  if($$record[-1][0] ne "tend") { print STDERR "End of bundle is not tend at position ",$$$record[-1][1],"\n";exit;}

  # DEBUG only:
  print STDERR "There are $n records\n";
  
  my $i=1; # current index for records
  
  my $lasts=0; # last computed tstart 
  my $laste=0; # last computed tend
  my $lastjs=0; # last valid jstart
  my $lastje=0; # last valid tend
  my $bundlend=$$record[0][1];
  my $s=0; # index of first record in current small bundle
  
  # record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point
  
  while($i<$n) {

    # DEBUG only:
    #print STDERR $$record[$i][0],"[",$i,"]:",$$record[$i][1]," w/drop[",$$record[$i][2][0],"]=",$$drop[$$record[$i][2][0]][2],"\n";

    # consider all types of record 
    if($$record[$i][0] eq "tstart") {
      if($$record[$i][3]) { # predicted tstart -> the percentage drop is 0 for tstart/tends in the bundle; if they are >0 then they are predicted

	# check if computed tstart is too close to a jend
	if($lastje && $$record[$i][1]-$$record[$lastje][1]<$smallwin && $$record[$lastje][3]<0.5) { # if this computed tstart is nearby a good junction, i.e with a drop<0.5 -> do not keep it 

	  my $j=$i-1; # if there are other records at this position update their records so they do not double count
	  while($j>=0 && (!$$record[$j][1] || $$record[$j][1]==$$record[$i][1])) { # skip deleted items
	    if($$record[$i][1]==$$record[$j][1]) {$$record[$i][4]=0;last;} # if position is the same delete its coverage 
	    $j--;
	  }
	  $$record[$i][1]=0; # delete its position to mark it as deleted
	}
	else { $lasts=$i;} # in this case I am keeping this predicted tstart
      }
      else { # this is a real start after the bundlend
	if($$record[$i-1][1]==$$record[$i][1] && $$record[$i-1][0] eq "jend") { # tstart is at the same place as jend
	  $$record[$i][1]=0; # do not keep it
	  $$record[$i][4]=0;
	}
	elsif($$record[$i][1]>$bundlend) { # I reached this start after bundle end -> print small bundle
	  $bundleno=print_small_bundle($record,$chr,$bundleno,$drop,$junc,$s,$i);
	  $s=$i; # next small bundle starts here
	}
      }
    }
    elsif($$record[$i][0] eq "tend") { # this is a transcription end
      if($$record[$i][3]) { # computed tend

	# check if tend is close to a jstart
	if($lastjs && $$record[$i][1]-$$record[$lastjs][1]<$smallwin  && $$record[$lastjs][3]<0.5) { # if this computed tstart is nearby a junction -> do not keep it (I added a requirement to have a significant drop)

	  my $j=$i-1; 
	  while($j>=0 && (!$$record[$j][1] || $$record[$j][1]==$$record[$i][1])) { 
	    if($$record[$i][1]==$$record[$j][1]) { $$record[$i][4]=0;last;}
	    $j--;
	  }
	  $$record[$i][1]=0;
	}
	else { $laste=$i;} # remember this computed tend
      }
      elsif($$record[$i-1][1]==$$record[$i][1] && $$record[$i-1][0] eq "jstart") { # tend is at the same place as jstart
	$$record[$i][1]=0; # do not keep it
	$$record[$i][4]=0;
      }
	
    }
    elsif($$record[$i][0] eq "jstart") { # this is a junction start

      # check validity and update bundlend
      my $nj=scalar(@{$$record[$i][2]}); # this are all the junctions with the same start as record[$i][1]
      my $found=0;
      for(my $j=0;$j<$nj;$j++) {
	if($$junc[$$record[$i][2][$j]][3]) { # valid junction
	  $found=1; # found a valid junction
	  if($$junc[$$record[$i][2][$j]][2]>$bundlend) { $bundlend=$$junc[$$record[$i][2][$j]][2];} # update bundle end
	}
      }
      if($found) { # there is at least one valid junction starting here
	# check if there is a computed tend nearby
	if($$record[$i][3]<0.5 && $laste && $$record[$i][1]-$$record[$laste][1]<$smallwin) {
	  my $j=$laste-1;
	  while($j>=0 && (!$$record[$j][1] || $$record[$j][1]==$$record[$laste][1])) {
	    if($$record[$laste][1]==$$record[$j][1]) { $$record[$laste][4]=0;last;}
	    $j--;
	  }
	  $$record[$laste][1]=0;
	  $laste=0;
	}
	$lastjs=$i;
      }
      else { # delete junction
	my $j=$i-1;
	while($j>=0 && (!$$record[$j][1] || $$record[$j][1]==$$record[$i][1])) {
	  if($$record[$i][1]==$$record[$j][1]) { $$record[$i][4]=0;last;}
	  $j--;
	}
	$$record[$i][1]=0;
      }
    }
    else { # this is a junction end
      my $nj=scalar(@{$$record[$i][2]});
      my $found=0;
      for(my $j=0;$j<$nj;$j++) {
	if($$junc[$$record[$i][2][$j]][3]) { # valid junction
	  if($$record[$i][3]<0.5 && $lasts && $$record[$i][1]-$$record[$lasts][1]<$smallwin) {
	    my $j=$lasts-1;
	    while($j>=0 && (!$$record[$j][1] || $$record[$j][1]==$$record[$lasts][1])) {
	      if($$record[$lasts][1]==$$record[$j][1]) { $$record[$lasts][4]=0;last;}
	      $j--;
	    }
	    $$record[$lasts][1]=0;
	    $lasts=0;
	  }
	  $lastje=$i;
	  $found=1;
	  last;
	}
      }
      if(!$found) { $$record[$i][1]=0;} # I do not have anything else at the same position before a jend so I do not need to delete record[i][4]
    }
    $i++;
  }

  $bundleno=print_small_bundle($record,$chr,$bundleno,$drop,$junc,$s,$i);
  
  return($bundleno);
}

## this function prints a group of records in the same bundle
sub print_small_bundle {
  my ($record,$chr,$bundleno,$drop,$junc,$s,$e)=@_;
  
  my $b=$s;
  
  my $sum=0;
  my $sumb=0; # sum to previous tstart -> to eliminate small covered regions under lowcov inside the bigger bundle
  my $found=0; # if I find junctions ending in this interval
  my $nl=0;
  my $reale=$e-1;
    
  for(my $i=$s;$i<$e;$i++) { # first pass to eliminate small covered portions and compute averages

    #print STDERR "record[$i]=",$$record[$i][0],"\t",$$record[$i][1],"\t(",join(":",@{$$record[$i][2]}),")\t",$$record[$i][3],"\t",$$record[$i][4],"\t",$$record[$i][5],"\n";    

    
    # record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point

    if(!$$record[$i][1]) { # if I deleted the record; just add its coverage to the sum so far
      $sum+=$$record[$i][4]+$$record[$i][5];
      if($b>=0) { $sumb+=$$record[$i][4]+$$record[$i][5];}
    }
    elsif($$record[$i][0] eq 'tend') { # tend
      $sum+=$$record[$i][4]+$$record[$i][5];
      $sumb+=$$record[$i][4]+$$record[$i][5];
      $nl++;
      if(!$$record[$i][3]) { # real end
	my $len=$$record[$i][1]-$$record[$b][1]+1;

	if(!$found && ($len<$win || $sumb/$len<$lowcov)) {
	  for(my $j=$b;$j<=$i;$j++) {
	    if($$record[$j][1]) {
	      $$record[$j][1]=0;
	      $nl--;
	    }
	  }
	}
	else { $reale=$i;}
	$b=-1;
	$sumb=0;
	$found=0;
      }
    }
    elsif($$record[$i][0] eq 'tstart') { # tstart
      $sum+=$$record[$i][4]+$$record[$i][5];
      $sumb+=$$record[$i][4]+$$record[$i][5];
      $nl++;
      if(!$$record[$i][3]) { # real start
	$b=$i;
	$found=0;
      }
    }
    else { # this is a junction
      $sum+=$$record[$i][4]+$$record[$i][5];
      $sumb+=$$record[$i][4]+$$record[$i][5];
      $nl++;
      $found=1;
    }
  }

  if($nl) {
    
	
    my $avg=$sum/($$record[$reale][1]-$$record[$s][1]+1);
    
    print "bundle\t$chr\t$bundleno\t",$$record[$s][1],"\t",$$record[$reale][1],"\t";
    printf "%.2f\n",$avg;
    $bundleno++;
    
    for(my $i=$s;$i<$e;$i++) {
      if($$record[$i][1]) { # if valid

	my $pos=0;
	if($$record[$i][0] eq "jend") { $pos=1;}
	elsif($$record[$i][0] eq "jstart") { $pos=2;}
	my $cov=get_next_cov($record,$i,$e,$drop,$junc,$pos);

	# type position drop cov_at_position cov_to_next [feature_cov|list_of_junction_ends:strand:feature_cov]
	print $$record[$i][0],"\t",$$record[$i][1],"\t";
	printf "%.6f\t",$$record[$i][3];
	print $$record[$i][4],"\t";
	printf "%.3f",$cov;

	
	if($pos) {	
	  my $nj=scalar(@{$$record[$i][2]});
	  for(my $j=0;$j<$nj;$j++) {
	    if($$junc[$$record[$i][2][$j]][3]) { # valid junction	    
	      print "\t",$$junc[$$record[$i][2][$j]][$pos],":",$$junc[$$record[$i][2][$j]][4],":",$$junc[$$record[$i][2][$j]][3];
	    }
	  }
	}
	else { # this is a tstart/tend
	  printf "\t%.2f",$$drop[$$record[$i][2][0]][2];
	}
	print "\n";
      }
    }
  }

  return($bundleno);
}
      
sub get_next_cov {
  my ($record,$i,$e,$drop,$junc,$pos)=@_;

  # record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point_in between points (0 if adjacent)
  
  my $cov=$$record[$i][5];

  my $start=$$record[$i][1];

  if(($$record[$i][0] eq "tstart")  || $pos==1 ) { # this is tstart or jend
    $cov+=$$record[$i][4];
  }
  else { $start++;}

  $i++;
  while($i<$e && !$$record[$i][1]) { # skipped record
    $cov+=$$record[$i][4]+$$record[$i][5];
    $i++;
  }

  my $len=0;
  
  if($i<$e) {
    if(($$record[$i][0] eq "tend") || ($$record[$i][0] eq "jstart")) {
      $cov+=$$record[$i][4];
      $len+=1;
    }
  }
  else { return(0);} # all points that follow are null

  $len+=$$record[$i][1]-$start;

  if($len) { 
    $cov/=$len;
  }


  
  return($cov);
}
  

sub get_record {
  my ($covg,$drop,$junc,$jend,$prevpos,$ib,$id,$js,$je,$nb,$nd,$nj,$record,$chr)=@_;

  my $nextd=0;
  my $nextjs=0;
  my $nextje=0;

  #print STDERR "$chr prevpos=$prevpos nextd=$nextd nextjs=$nextjs nextje=$nextje $ib,$id,$js,je=$je,$nb,$nd,$nj\n";
  
  if($id<$nd) { $nextd=abs($$drop[$id][0]);} # next drop position
  while($js<$nj) {
    if($$junc[$js][3]) {      
      $nextjs=$$junc[$js][1];
      last;
    }
    $js++;
  } # next junc start
  while($je<$nj) { # junc end
    if($$junc[$$jend[$je]][3]) { # if I kept the junction at its start -- when do I eliminate junctions?
      $nextje=$$junc[$$jend[$je]][2];
      last;
    }
    $je++;
  }

  #print STDERR "$chr prevpos=$prevpos nextd=$nextd nextjs=$nextjs nextje=$nextje $ib,$id,$js,$je,$nb,$nd,$nj\n";

  if(!$nextd && !$nextjs && !$nextje) { # only happens if $je reaches $nj, and all the other were already maxed out
    if($id==$nd && $js==$nj && $je ==$nj) { return($ib,$id,$js,$je,$prevpos);}
    print STDERR "All null $chr prevpos=$prevpos nextd=$nextd nextjs=$nextjs nextje=$nextje $ib,$id,$js,$je,$nb,$nd,$nj\n";
    exit;
  }

  # if all equal order is nextje nextjs nextd

  if(less($nextd,$nextjs)) { # start/stop comes before junction start
    if(less($nextd,$nextje)) { # start/stop comes before junction end => start/stop is smallest
      
      if($nextd>$prevpos+1) { 
	my $avgcov=0;
	($avgcov,$ib)=get_cov($prevpos+1,$nextd-1,$covg,$ib,$nb); 
	$$record[-1][-1]+=$avgcov; # there is always a previous record due to tstart
      }

      my $cov=0;
      ($cov,$ib)=get_cov($nextd,$nextd,$covg,$ib,$nb); # get coverage at position

      while($id<$nd && abs($$drop[$id][0])==$nextd) { # I am at the same position --> advance; how can it be that I stay at the same position - WHY??

	my $type="tstart";      
	if($$drop[$id][0]<0) { $type="tend";}

	# check if this start/end should delete a previously added junction
	if(!$$drop[$id][1] && $prevpos>$nextd-$delta) { # only in this case I am interested in checking previous junctions
	  if($type eq "tstart") { # here I can only look at the same position - because all the jstart need to come after tstart (their anchors are less then delta)
	    if($$record[-1][1]==$nextd && ($$record[-1][0] eq "jstart")) { # delete all junctions starting here
	      for(my $j=0;$j<scalar(@{$$record[-1][2]});$j++) {
		$$junc[$$record[-1][2][$j]][3]=0;
	      }
	    }
	  }
	  else { # this is a tend	    
	    my $nr=scalar(@{$record});
	    my $i=$nr-1;
	    while($i>=0 && $$record[$i][1]>$nextd-$delta) {
	      if($$record[$i][0] eq "jend") {
		for(my $j=0;$j<scalar(@{$$record[$i][2]});$j++) { # delete all junctions ending here
		  $$junc[$$record[$i][2][$j]][3]=0;
		}
	      }
	      $i--;
	    }
	  }
	}
	
	# record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point

	push(@{$record},[($type,$nextd,[($id)],$$drop[$id][1],$cov,0)]);
       
	$id++;
      }

      $prevpos=$nextd;
      
    }
    elsif($nextje) { # nextje is smallest and it always comes before nextjs/nextd at same position

      my @tmpr; # this is a temp record to store junctions that end at the same point
      my $count=0;
      my $present=0;
      while($je<$nj && $$junc[$$jend[$je]][2]==$nextje) { # while at the same position
	if($$junc[$$jend[$je]][3]) { # this is a good junction (it might have been deleted by jstart)
	  push(@tmpr,$$jend[$je]);
	  $count+=$$junc[$$jend[$je]][3];
	}
	$je++;
      }

      if($count) { # I found good junctions; count represents their total coverage
	$present=1;
	
	# check if junction is valid
	my $tmpib=$ib;
	my $leftstart=$nextje-$delta;
	if($leftstart<$$covg[0][0]) { $leftstart=$$covg[0][0];$tmpib=0;}
	else { while($$covg[$tmpib][0]>$leftstart) { $tmpib--;}}      
	my $leftcov=0;
	($leftcov,$tmpib)=get_cov($leftstart,$nextje-1,$covg,$tmpib,$nb);      
	
	my $rightend=$nextje+$delta-1;
	if($rightend>$$covg[$nb-1][1]) { $rightend=$$covg[$nb-1][1];}
	my $rightcov=0;
	($rightcov,$tmpib)=get_cov($nextje,$rightend,$covg,$tmpib,$nb);

	if($leftcov<$rightcov) { # this is a valid junction -> might add it to the record

	  # first check that junction end is good (not within delta bp from a tstart or within a 1bp from the same type)
	  my $prevcount=0;
	  my $prevjend=0;
	  if($prevpos>$nextje-2) { # otherwise I am not interested in checking this
	    my $nr=scalar(@{$record});
	    my $i=$nr-1;
	    while($i>=0 && $$record[$i][1]>$nextje-2) {
	      if($$record[$i][1]==$nextje-1 && $$record[$i][0] eq "jend") {
		$prevjend=$i;
		for(my $j=0;$j<scalar(@{$$record[$i][2]});$j++) {
		  $prevcount+=$$junc[$$record[$i][2][$j]][3];
		}
	      }
	      $i--;
	    }
	  }
	  
	  if($prevcount<$count) { # survived prevcount

	    # delete junctions of prevcount if needed
	    if($prevcount) {
	      for(my $j=0;$j<scalar(@{$$record[$prevjend][2]});$j++) {
		$$junc[$$record[$prevjend][2][$j]][3]=0;
	      }
	    }

	    if($nextje>$prevpos+1) {
	      my $avgcov=0;
	      ($avgcov,$ib)=get_cov($prevpos+1,$nextje-1,$covg,$ib,$nb);
	      $$record[-1][-1]+=$avgcov;
	    }

	    my $cov=0;
	    ($cov,$ib)=get_cov($nextje,$nextje,$covg,$ib,$nb);

	    # record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point
	    push(@{$record},[("jend",$nextje,[@tmpr],$leftcov/$rightcov,$cov,0)]);

	    $prevpos=$nextje;
	  }
	  else { $count=0;}
	}
	else { $count=0;}
      }
      if($present && !$count) { # I need to delete junctions
	for(my $j=0;$j<@tmpr;$j++) {
	  $$junc[$tmpr[$j]][3]=0;
	}
      }
    }
  }
  else { # $nextjs is smaller than start/stop or 0
    if(less($nextjs,$nextje)) { # nextjs is smallest and comes before nextd but after nextje

      my @tmpr; # this is a temp record to store junctions that start at the same point
      my $count=0;
      my $present=0;
      while($js<$nj && $$junc[$js][1]==$nextjs) { # while at the same position
	if($$junc[$js][3]) { # this is a good junction 
	  push(@tmpr,$js);
	  $count+=$$junc[$js][3];
	}
	$js++;
      }

      if($count) { # I found good junctions

	$present=1;

	# first check that junction start is good (not same as end or within 1bp from the same type)
	my $prevcount=0;
	my $prevjstart=0;
	if($prevpos>$nextjs-$delta) { # otherwise I am not interested in checking this
	  my $nr=scalar(@{$record});
	  my $i=$nr-1;
	  while($i>=0 && $$record[$i][1]>$nextjs-$delta) {
	    if((!$$record[$i][3] && ($$record[$i][0] eq "tstart")) || ($$record[$i][1]==$nextjs && $$record[$i][0] eq "jend")) { # tstart precedes nearby or jend passed the leftcov/rightcov threshold at same position
	      $count=0;
	      last;
	    }
	    elsif($$record[$i][1]==$nextjs-1 && $$record[$i][0] eq "jstart") {
	      $prevjstart=$i;
	      for(my $j=0;$j<scalar(@{$$record[$i][2]});$j++) {
		$prevcount+=$$junc[$$record[$i][2][$j]][3];
	      }
	    }
	    $i--;
	  }
	}

	if($prevcount<$count) { # survived jend and prevcount
	
	  # check if junction is valid
	  my $tmpib=$ib;
	  my $leftstart=$nextjs-$delta+1;
	  if($leftstart<$$covg[0][0]) { $leftstart=$$covg[0][0];$tmpib=0;}
	  else { while($$covg[$tmpib][0]>$leftstart) { $tmpib--;} }	       
	  my $leftcov=0;
	  ($leftcov,$tmpib)=get_cov($leftstart,$nextjs,$covg,$tmpib,$nb);

	  my $rightend=$nextjs+$delta;
	  if($rightend>$$covg[$nb-1][1]) { $rightend=$$covg[$nb-1][1];}
	  my $rightcov=0;
	  ($rightcov,$tmpib)=get_cov($nextjs+1,$rightend,$covg,$tmpib,$nb);

	  if($leftcov>$rightcov) { # there is a delta drop in coverage => valid junction	 

	    # delete junctions of prevcount if needed
	    if($prevcount) {
	      for(my $j=0;$j<scalar(@{$$record[$prevjstart][2]});$j++) {
		$$junc[$$record[$prevjstart][2][$j]][3]=0;
	      }
	    }

	    if($nextjs>$prevpos+1) {
	      my $avgcov=0;
	      ($avgcov,$ib)=get_cov($prevpos+1,$nextjs-1,$covg,$ib,$nb);
	      $$record[-1][-1]+=$avgcov;
	    }

	    my $cov=0;
	    ($cov,$ib)=get_cov($nextjs,$nextjs,$covg,$ib,$nb);
	


	    # record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point
	    push(@{$record},[("jstart",$nextjs,[@tmpr],$rightcov/$leftcov,$cov,0)]);

	    $prevpos=$nextjs;
	  }
	  else { $count=0;}
	}
	else { $count=0;}
      }
      if($present && !$count) { # I need to delete junctions
	for(my $j=0;$j<@tmpr;$j++) {
	  $$junc[$tmpr[$j]][3]=0;
	}
      }
    }
    elsif($nextje) { # nextje is smallest

      my @tmpr; # this is a temp record to store junctions that end at the same point
      my $count=0;
      my $present=0;
      while($je<$nj && $$junc[$$jend[$je]][2]==$nextje) { # while at the same position
	if($$junc[$$jend[$je]][3]) { # this is a good junction (it might have been deleted by jstart)
	  push(@tmpr,$$jend[$je]);
	  $count+=$$junc[$$jend[$je]][3];
	}
	$je++;
      }

      if($count) { # I found good junctions
	$present=1;
	
	# check if junction is valid
	my $tmpib=$ib;
	my $leftstart=$nextje-$delta;
	if($leftstart<$$covg[0][0]) { $leftstart=$$covg[0][0];$tmpib=0;}
	else { while($$covg[$tmpib][0]>$leftstart) { $tmpib--;}}      
	my $leftcov=0;
	($leftcov,$tmpib)=get_cov($leftstart,$nextje-1,$covg,$tmpib,$nb);      
	
	my $rightend=$nextje+$delta-1;
	if($rightend>$$covg[$nb-1][1]) { $rightend=$$covg[$nb-1][1];}
	my $rightcov=0;
	($rightcov,$tmpib)=get_cov($nextje,$rightend,$covg,$tmpib,$nb);

	if($leftcov<$rightcov) { # this is a valid junction -> might add it to the record

	  # first check that junction end is good (not within delta bp from a tstart or within a 1bp from the same type)
	  my $prevcount=0;
	  my $prevjend=0;
	  if($prevpos>$nextje-2) { # otherwise I am not interested in checking this
	    my $nr=scalar(@{$record});
	    my $i=$nr-1;
	    while($i>=0 && $$record[$i][1]>$nextje-2) {
	      if($$record[$i][1]==$nextje-1 && $$record[$i][0] eq "jend") {
		$prevjend=$i;
		for(my $j=0;$j<scalar(@{$$record[$i][2]});$j++) {
		  $prevcount+=$$junc[$$record[$i][2][$j]][3];
		}
	      }
	      $i--;
	    }
	  }
	  
	  if($prevcount<$count) { # survived prevcount

	    # delete junctions of prevcount if needed
	    if($prevcount) {
	      for(my $j=0;$j<scalar(@{$$record[$prevjend][2]});$j++) {
		$$junc[$$record[$prevjend][2][$j]][3]=0;
	      }
	    }

	    if($nextje>$prevpos+1) {
	      my $avgcov=0;
	      ($avgcov,$ib)=get_cov($prevpos+1,$nextje-1,$covg,$ib,$nb);
	      $$record[-1][-1]+=$avgcov;
	    }

	    my $cov=0;
	    ($cov,$ib)=get_cov($nextje,$nextje,$covg,$ib,$nb);
	

	    # record: 0:type(tstart,tend,jstart,jend) 1:positionstart 2:list of position in records (drop/junc) 3:change_percentage 4:position_coverage 5:coverage_to_next_point
	    push(@{$record},[("jend",$nextje,[@tmpr],$leftcov/$rightcov,$cov,0)]);

	    $prevpos=$nextje;
	  }
	  else { $count=0;}
	}
	else { $count=0;}
      }

      if($present && !$count) { # I need to delete junctions
	for(my $j=0;$j<@tmpr;$j++) {
	  $$junc[$tmpr[$j]][3]=0;
	}
      }
    }
  }

  #print STDERR "prevpos=$prevpos ib=$ib nb=$nb,id=$id nd=$nd ,js=$js,je=$je nj=$nj type=",$$record[-1][0],"\n";

  return($ib,$id,$js,$je,$prevpos);
}

sub less {
  my ($n1,$n2)=@_;
  if(!$n1) { return(0);}

  if(!$n2) { return(1);}

  if($n1<$n2) { return(1);}

  return(0);
}

sub get_drop { # compute drops in coverage in bundles > win+smallwin
  
  my ($covg,$si,$se,$drop,$nb,$junc,$jend,$js,$je,$nj)=@_; # jend are indices of junc - I need to account for this

  my $start=$$covg[$si][0];
  my $end=$$covg[$se][1];
  
  #print STDERR "Get drop btw: $start-$end len=",$end-$start+1," si=$si se=$se\n";

  while($js<$nj && $$junc[$js][1]<$start) { $js++;} # advance junction start past $start
  while($je<$nj && $$junc[$$jend[$je]][2]<$start) { $je++;}   # advance junction end past $start

  #if($je==$nj || $$junc[$$jend[$je]][2]>$start) { # only if this is not a junction end it is a tstart -> no need to check this now -> will check again later
    push(@{$drop},[($start,0,$$covg[$si][2])]); # 0: position; 1: drop percentage; 2: coverage difference across window size 
  #}

  my $len=$end-$start+1;
  if($len>=$win+$smallwin) { # only in this case process drop   

    my @c; # coverage sums up to position i
    my @as; # adjusted values
    my @ae; # adjusted values
    my @jp; # junction points
    $c[0]=0; # this is to assure I always have something to substract on the left -> coordinates will be 1-based now
    $as[0]=0;
    $ae[0]=0;
    
    for(my $i=0;$i<$len;$i++) {
      my $istart=$i+$start;
      while($istart>$$covg[$si][1]) { $si++; } # advance start covg
      my $i1=$i+1;
      $c[$i1]=$$covg[$si][2];
      my $r=$i%$win;
      if($r) {
	$c[$i1]+=$c[$i];
	$as[$i1]+=$as[$i];
	$ae[$i1]+=$ae[$i];
      }

      my $isjunc=0;
      if($js<$nj && $$junc[$js][1]==$istart) { # junction start here

	my $cov=$$junc[$js][3];
	$js++;
	while($js<$nj && $$junc[$js][1]==$istart) { $cov+=$$junc[$js][3];$js++;}

	for(my $j=1;$j<$r+2;$j++) {
	  $as[$i-$r+$j]+=$cov*$j;
	}
	
	if($i>$win) { for(my $j=1;$j<$win-$r;$j++) { # only in this case I have coverages before the multiple of $win
	  $as[$i-$win+$j+1]+=$cov*$j;
	}}
	
	
	push(@jp,$i1); # junction at this position
	$isjunc=1;
      }      

      if($je<$nj && $$junc[$$jend[$je]][2]==$istart) { # junction end here
	my $cov=$$junc[$$jend[$je]][3];
	$je++;
	while($je<$nj && $$junc[$$jend[$je]][2]==$istart) { $cov+=$$junc[$$jend[$je]][3];$je++;}

	for(my $j=0;$j<$win;$j++) { $ae[$i1+$j]+=$cov;}
	if(!$isjunc) { push(@jp,$i1); } # junction at this position
      }           
    }

    my $j=0; # junc index
    my $i=$smallwin+1;

    my @tmps; # starts 0:pos 1:perc 2:coverage 3:active  
    my @tmpe; # ends
    my $maxs=0; # maximal drop for starts
    my $maxe=0; # maximal drop for ends
    
    while($i<$len-$smallwin) { 

      my $l=$i-$win;
      if($l<1) { $l=1;} # make sure that there is c[0] present to compute difference

      my $r=2*$i-$l-1;
      if($r>$len-1) { $r=$len-1; $l=2*$i-$r-1;}


      #print STDERR "Evaluate $i at position:",$i+$start,"\n";      
      
      my ($minpercl,$minpercr,$minavgl,$minavgr)=compute_perc($l,$r,$i,\@c,\@as,\@ae);


      while($j<@jp && $jp[$j]<=$l) { $j++;}

      my $k=$j;
      while($k<@jp && $jp[$k]<$r) { 
	if($i-$jp[$k]>$smallwin) { # only if i it's far enough
	  my ($percl,$percr,$avgl,$avgr)=compute_perc($jp[$k],2*$i-$jp[$k]-1,$i,\@c,\@as,\@ae);
	  if($percl<$minpercl) { $minpercl=$percl; $minavgl=$avgl;}
	  if($percr<$minpercr) { $minpercr=$percr; $minavgr=$avgr;}
	}
	elsif($jp[$k]-$i+1>$smallwin) { # only if i it's far enough
	  my ($percl,$percr,$avgl,$avgr)=compute_perc(2*$i-$jp[$k]-1,$jp[$k],$i,\@c,\@as,\@ae);
	  if($percl<$minpercl) { $minpercl=$percl; $minavgl=$avgl;}
	  if($percr<$minpercr) { $minpercr=$percr; $minavgr=$avgr;}
	}
	$k++;
      }

      #if($i+$start==29512162 29,360,069) { print STDERR "$i:minpercr=$minpercr minavgr=$minavgr minpercl=$minpercl $minavgl=$minavgl\n";   exit;}

      ## watch for this junction: chr22:17,138,145-17,138,167 when doing the parsing
      
      my $plus=0;
      if($minpercr<$percnoise) { # start
	
	if(@tmps) { # I have a current max
	  push(@tmps,[($i,$minpercr,$minavgr,1)]);			 
	  if($i-$tmps[$maxs][0]>$win) {
	    if($tmps[-2][1]>=$minpercr || $i-$tmps[-2][0]>$win) { # time to compute a new max
	      $maxs=scalar(@tmps)-1;
	      $k=$maxs-1;
	      while($k>=0 && $i-$tmps[$k][0]<=$win) {
		if($minpercr>$tmps[$k][1]) { $maxs=$k;$tmps[-1][3]=0;}
		else { $tmps[$k][3]=0;}
		$k--;
	      }
	    }
	    else { $tmps[-1][3]=0;}
	  }
	  elsif($minpercr<$tmps[$maxs][1]) { $tmps[$maxs][3]=0;$maxs=scalar(@tmps)-1;}
	  else { $tmps[-1][3]=0;}
	}
	else { # this is the first drop I encounter
	  push(@tmps,[($i,$minpercr,$minavgr,1)]);			 
	}
	$plus=1;
      }

      if($minpercl<$percnoise) { #end
	
	if(@tmpe) { # I have a current max
	  push(@tmpe,[($i,$minpercl,$minavgl,1)]);			 
	  if($i-$tmpe[$maxe][0]>$win) {
	    if($tmpe[-2][1]>=$minpercl || $i-$tmpe[-2][0]>$win) { # time to compute a new max
	      $maxe=scalar(@tmpe)-1;
	      $k=$maxe-1;
	      while($k>=0 && $i-$tmpe[$k][0]<=$win) {
		if($minpercl>$tmpe[$k][1]) { $maxe=$k;$tmpe[-1][3]=0;}
		else { $tmpe[$k][3]=0;}
		$k--;
	      }
	    }
	    else { $tmpe[-1][3]=0;}
	  }
	  elsif($minpercl<$tmpe[$maxe][1]) { $tmpe[$maxe][3]=0;$maxe=scalar(@tmpe)-1;}
	  else { $tmpe[-1][3]=0;}
	}
	else { # this is the first drop I encounter
	  push(@tmpe,[($i,$minpercl,$minavgl,1)]);			 
	}
	$plus=1;
      }
      
      if(!$plus && $minpercl>0.5 && $minpercr>0.5) { $plus=$delta;}
      else { $plus=1;}

      $i+=$plus;
    }

    my $ns=scalar(@tmps);
    my $ne=scalar(@tmpe);

    my $s=0;
    my $e=0;

    while($s<$ns && $e<$ne) {
      if($tmpe[$e][0]<$tmps[$s][0]) {
	if($tmpe[$e][3]) { push(@{$drop},[(-($tmpe[$e][0]+$start-2),$tmpe[$e][1],$tmpe[$e][2])]);}	
	$e++;
      }
      else {
	if($tmps[$s][3]) {
	  if($tmpe[$e][3] && $tmpe[$e][0]==$tmps[$s][0]) { print STDERR "Same start and end at position ",$tmpe[$e][0],"(",$tmpe[$e][0]+$start-1,") s=$s e=$e\n";exit;}					  
	  push(@{$drop},[($tmps[$s][0]+$start-1,$tmps[$s][1],$tmps[$s][2])]);
	}
	$s++;
      }
    }
    while($s<$ns) {
      if($tmps[$s][3]) { push(@{$drop},[($tmps[$s][0]+$start-1,$tmps[$s][1],$tmps[$s][2])]);}
      $s++;
    }
    while($e<$ne) {
      if($tmpe[$e][3]) { push(@{$drop},[(-($tmpe[$e][0]+$start-2),$tmpe[$e][1],$tmpe[$e][2])]);}	
      $e++;
    }
  }

  if($js) { $js--;}
  while($js<$nj && $$junc[$js][1]<$end) { $js++;}
  # if($js==$nj || $$junc[$js][2]>$end) { # only if this is not a junction start it is a tend -> no need to check this now -> will check again later
    push(@{$drop},[(-$end,0,$$covg[$se][2])]);
  # }

  return($js,$je);
}

sub compute_perc {
  my ($l,$r,$i,$cov,$adjs,$adje)=@_;

  my $percl=1;
  my $percr=1;
  my $avgl=0;
  my $avgr=0;

  my $sumleft=$$cov[$i-1]-$$cov[$l-1];
  my $sumlefta=$$adjs[$i-1]-$$adjs[$l-1];
  my $k=($i-2)%$win;
  my $kw=$i-1-$k;
  if($kw<$i && $kw>=$l) {
    $sumleft+=$$cov[$kw-1];
    $sumlefta+=$$adjs[$kw-1];
  }
  $sumlefta=$sumleft-$sumlefta;

  # DEBUG only:
  #if($sumlefta<0 ) { 
  #  print STDERR "l=$l,i=$i,r=$r sumleft=$sumleft sumlefta=$sumlefta  kw=$kw\n";
  #  for(my $j=$l-1;$j<$r+1;$j++) {
  #    print STDERR $j-$l+1,":",$$cov[$j]," ";
  #  }
  #  print STDERR "\n";
  #  exit;
  #}
  
    
  my $sumright=$$cov[$r]-$$cov[$i-1];
  my $sumrighta=$$adje[$r]-$$adje[$i-1];
  $k=($r-1)%$win;
  $kw=$r-$k;
  if($kw-1<$r && $kw>=$i) {
    $sumright+=$$cov[$kw-1];
    $sumrighta+=$$adje[$kw-1];
  }
  $sumrighta=$sumright-$sumrighta;

  # DEBUG only:
  #if($sumrighta<0 ) { 
  #  print STDERR "l=$l,i=$i,r=$r sumleft=$sumleft sumlefta=$sumlefta sumright=$sumright sumrighta=$sumrighta kw=$kw\n";
  #  for(my $j=$l-1;$j<$r+1;$j++) {
  #    print STDERR $j-$l+1,":",$$cov[$j]," ";
  #  }
  #  print STDERR "\n";
  #  exit;
  #}

  if($sumleft <0 || $sumright<0) { print STDERR "Negative coverage for window $l,$i,$r sumleft=$sumleft $sumright=$sumright\n";exit;}

  if($sumlefta>$sumright) {
    $avgl=($sumlefta-$sumright)/($i-$l);
    $percl=$sumright/$sumlefta;
  }

  if($sumrighta>$sumleft) {
    $avgr=($sumrighta-$sumleft)/($i-$l);
    $percr=$sumleft/$sumrighta;
  }
    
  return($percl,$percr,$avgl,$avgr);
}
  

sub get_cov { # this ignores gaps between coverages
  my ($start,$end,$covg,$si,$nb)=@_;

  my $cov=0;

  while($si<$nb && $start>$$covg[$si][1]) { $si++; } # advance start covg

  if($si==$nb) { return($cov,$si);}

  # ignore gaps in coverage
  if($start<$$covg[$si][0]) { $start=$$covg[$si][0];} 
  
  while($end>$$covg[$si][1]) {
    $cov+=($$covg[$si][1]-$start+1)*$$covg[$si][2];
    $si++;
    if($si==$nb) { return($cov,$si);}
    $start=$$covg[$si][0];
  }
  
  if($end<$start) { return($cov,$si);}
  
  $cov+=($end-$start+1)*$$covg[$si][2];  

  return($cov,$si);
}

sub add_procjunc_to_bundle { # these junctions were already read from the file, but they might still adjust the bundleend
  my ($junc,$unprocjunc,$bundleend,$chr)=@_;

  # junc: 0:chrname 1:start 2:end 3:cov 4:strand
  
  my $nj=scalar(@{$unprocjunc});

  if(!$nj) { return(1);} # there are no unprocessed junctions -> need to look into the file

  my $j=0;
  while($j<$nj) { # there are still junctions to add

    if(($$unprocjunc[$j][0] ne $chr) || $$unprocjunc[$j][1]>$$bundleend) { # this junction is beyond the bundle end
      if($j) { # there are unprocessed junctions that need to be added to bundle
	my @js=splice(@{$unprocjunc},0,$j); # this removes the first $j junctions and adds them to @js

	# DEBUG only:
	#print STDERR "Add junctions to junc:\n";
	#for(my $i=0;$i<scalar(@js);$i++) {
	#  print STDERR join("\t",@{$js[$i]});
	#}
	#print STDERR "\n";

	push(@{$junc},@js);
      }
      return(0);
    }
    if($$unprocjunc[$j][2]>$$bundleend) {
      $$bundleend=$$unprocjunc[$j][2];
    }
    $j++;
  }

  if($j) { # all unprocessed junctions that need to be added to bundle
    my @js=splice(@{$unprocjunc},0,$j);

    # DEBUG only:
    #print STDERR "Add junctions to junc:\n";
    #for(my $i=0;$i<scalar(@js);$i++) {
    #  print STDERR join("\t",@{$js[$i]});
    #}
    #print STDERR "\n";

    push(@{$junc},@js);
  }
  return(1);
}


sub add_junc_to_bundle {
  my ($junc,$unprocjunc,$chr,$bundleend,$fJ)=@_; # read junctions from junction file and add them to junc if they are still inside the bundle; otherwise keep them in unprocjunc until they are ready to be added to junc

  while(<$fJ>) { # read the junction file line by line

    my ($chrname,$start,$end,$name,$cov,$strand,$percs)=split(/\t/); # info on a line in junction file
    
    chomp($percs);
    my ($ps,$po,$pl,$pr)=split(/\-/,$percs); # split the 4 percentages in the line (separated by '-')
    my $d = $ps < $po ? $ps : $po; # d is minimum of the first two percentages in the file refer to the percentage out of the maximum count overlaping junction (on the same strand, ps) or opposite strand (po)
    my $p = $pl < $pr ? $pl : $pr; # take minimum percent on the ends; the last 2 percentages are the the percentage of the maximum count at the beginning (left) and end (right) of junction
    
    my $last=0;
    if(($chrname ne $chr) || ($start>$bundleend)) { # this is the last junction to read from file if junction goes out of current bundle
      $last=1;
    }

    #print STDERR "chr=$chr chrname=$chrname bundleend=$bundleend last=$last\n";
    
    if(($ps>$splicenoise || $po>$splicenoise) && (($cov>=$lowcov && $strand ne '.') || $cov>=$smallcov)) { # I can only accept junctions above the splicenoise from the overlapping maximal junction on the same strand and are above the lowcov(def.10) if stranded, or above smallcov (def.50) otherwise -> stricter criteria for unstranded junctions

      if(($cov>$highcov && $strand ne '.') || ($p>$splicenoise && ($d>$splicenoise || ($d>$highnoise && $cov>$smallcov && $strand ne '.')))) { # accept all stranded junctions above highcov(def.100) or if lower filter them based on the splicenoise percentage at the end
	$end++; # adjust end to reflect start of next exon
	if(!$last) { # this is not the last junction to consider
	  if($end>$bundleend) { # adjust bundle end if needed
	    $bundleend=$end;	  
	  }
	  push(@{$junc},[($chrname,$start,$end,$cov,$strand,$ps)]); # store junction
	}      
	else { 
	  #print STDERR "unprocjunc $chrname ",$start," ",$end-1," bundleend=",$bundleend," cov=$cov p=$p d=$d newend=$end\n";		
	  push(@{$unprocjunc},[($chrname,$start,$end,$cov,$strand,$ps)]);  # store unprocessed junction
	}
      }
    }

    if($last) { return($bundleend);} # no need to read anymore if junction starts after bundleend
  }

  return($bundleend);
}

sub process_junctions { ## this function can be developped in the future to process retaines junctions; now it only removes lower count junctions that overlap junctions that are under smallcov (50); i.e. if junction j overlaps i and count(j)<count(i)<smallcov remove j
 

  my ($junc,$jend,$nj)=@_;

  # junc 0:chrname 1:start 2:end 3:cov 4:strand 5:percentage of maximal overlapping junction  

  my $js=0;
  my $je=0;

  ## my @maximal; not used now; I might use these two for smarter evaluation in the future
  ## my %overlap; not used now; I might use these two for smarter evaluation in the future
  
  my %active;

  my %mark; # this might not be used in the future as such
  
  while($js<$nj) { # look at junction starting js

    # first check if I have active junctions before here
    while($je<$nj && $$junc[$$jend[$je]][2]<$$junc[$js][1]) {
      my $key=join(":",($$junc[$$jend[$je]][0],$$junc[$$jend[$je]][1],$$junc[$$jend[$je]][4]));
      if($active{$key}) { delete $active{$key};}
      $je++;
    }

    ## $maximal[$js]=1;

    foreach my $k (keys %active) {
      if(equal_strand($$junc[$active{$k}][4],$$junc[$js][4])) {
	## push(@{$overlap{$active{$k}}},$js);
	## push(@{$overlap{$js}},$active{$k});
	if($$junc[$js][3]>$$junc[$active{$k}][3]) { # this junction is better
	  ## $maximal[$active{$k}]=0;
	  if($$junc[$js][3]<$smallcov) { $mark{$active{$k}}=1;}
	}
	elsif($$junc[$js][3]<$$junc[$active{$k}][3]) {
	  ## $maximal[$js]=0;
	  if($$junc[$active{$k}][3]<$smallcov) { $mark{$js}=1;}
	}
      }
    }

    my $key=join(":",($$junc[$js][0],$$junc[$js][1],$$junc[$js][4]));
    $active{$key}=$js;
    
    $js++;
  }

  foreach my $j (keys %mark) { $$junc[$j][3]=0;}

  #if($$junc[0][1]>15488073 ) { exit;}
}

sub equal_strand { # computes if 2 strands are equal (yes if one strand is undefined)
  my ($s1,$s2)=@_;

  if($s1 eq $s2) { return(1);}
  if($s1 eq "." || $s2 eq ".") { return(1);}

  return(0);
}
